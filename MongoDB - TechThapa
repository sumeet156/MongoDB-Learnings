• What is MongoDB?
   OpenSource, Doc-oriented(document store/ db that store information in doc.) NoSQL db management system         
   It is stored in JSON(JavaScript Object Notation)
   Designed for flexibility,scalability, and performance in handling unstructured or semi-structured data. 
   
• More about MongoDB : created by 10gen later changed to MongoDB (2009). Humongous (big derived from this) - Mongo

   # SQL vs MongoDB
     - SQL (Structured query language): Stores data in table format (rows and columns) / db are relational dbs
                                    suited for well-defined schemas and fixed data structures
           Ex. E-commerce platform, HR Management(payrolls) etc
               MySQL, PostgreSQL, Oracle
  
     - MongoDB: NoSQL db are non-relational database. They Provide flexibility in data storage, allows varied data types and structures.
                Ideal for applications with dynamic or evolving data models.
                CMS, Social media platforms, Gaming
           Ex. MongoDB, Cassandra, Redis
          Inside one collection we can have multiple documents

• MongoDb Teminology and Advantages: 

     Database -> Collections (we can have multiple documents) -> Students / teachers / Products (Collection) -> Student ka alag doc hota hai teacher ka alag there details etc.
        it can be schemaless too
      

• Key Features:
   #Flexible Schema Designs, Scalability and performance, Document oriented storage, Dynamic quries, aggregation framework, Open Source and community
  
•  How works? -> Frontend + Backend + DB - MongoShell se bhi connect karke kar sakte hai (Storage Engine [Converts JSON to BSON]- to talk with Db and do crud operations)

• JSON vs BSON :
  - In MongoDB, we write in JSON format only but behind the scene data is stored in BSON (Binary JSON) format, a binary reprepntation of JSON.
  - By utilizing BSON, MongoDB can achieve higher read and write speeds, reduced storage requirements, and improved data manipulation capabilities,
  making it well-suited for handling large and complex datasets while maintaining performance efficiency.
  - JSON is easy to read and write     

Managing Db and collections:
  > show dbs;    -- to see the databases
  > use <database-name>;   --to use the created db 
  > db.dropDatabase();    -- to delete the db

  > show collections;  
  > db.createCollection('<collection-name>');      --to create collection
  > db.<collection-name>.drop();  

Open Cmd-> mongosh (enter) -> you created server of mogosh now you can run commands

  - You wonlt see a database listed in the output of the show dbs command until that database contains at least one collection with data in it.
  


• Insert Operation in MongoDB
  - Inserting Documents in MongoDB (single document): db.<collection-name>.insertOne({field:vlaue1, field2:value2, .... });
 
 - Inserting Multiple Documents (Array of an obj [] in square brackets): db.<collection-name>.insertMany([
                                    {fieldl: valuel, field2: value2, ...},
                                    {fieldl: valuel, field2: value2, ...},
                                    // .....
                                 ]);

  - When to use Quotes and when not to?
    • Special Characters: If a field name contains special characters or spaces, or starts with a numeric digit, using quotes is necessary.
    • Reserved Words: If a field name is a reserved keyword in MongoDB, use quotes distinguish it from the reserved keyword.

 (Best Practice: Always use single or double qoutes)


• Ordered and Unordered Inserts: hen executing bulk write operations, "ordered" and "unordered" determine the batch behavior.
  - Ordered Inserts: Default behavior is ordered, where MongoDB stops on the first error.
                     db.<coIIection-name>.insertMany([ docl, doc2, ... l);

  - Unordered Inserts: When executing bulk write operations with unordered flag, MongoDB processing after encountering an error.
                      db.<collection-name>.insertMany([ docl, doc2, ... J, { ordered: false });


• Case Sensitivity in MongoDB:
  - Collection names are case-sensitive.
  - Field names within documents are also case-sensitive.
        db.Product.insertOne({ name: 'summe', age: 30 });     -- Product database and 
        db.product.insertOne({ name: 'summe', age: 30 });     -- product database are completely diff.


• Read Operations in MongoDB: Reading Documents in MongoDB, Comparison Operators, Logical Operators, Cursors in MongoDB, Elements Operators

  - Finding Documents in MongoDB: find() : db.collection_name.find({ key: value })     -- it will show all result in collection
                                  findOne() : db.collection_name.findOne({ key: value })    -- it will show only one result 

 
• Importing JSON in MongoDB: mongoimport jsonfile.json —d database_name —c collection_name
  - mongoimport products.json -d shop -c products    (if json is not in array then do this)
  - mongoimport products.json -d shop -c products —jsonArray        (if json is in array then do this)
  
  - mongoexport products.json -d shop -c products 

(mongoimport and mongoexport are command-line utilities that are part of the MongoDB Database Tools. These tools are used for importing data into MongoDB (using mongoimport) and exporting data from MongoDB (using mongoexport)

  - Limited to imports of 16 MB or smaller.


• Comparison Operators:  db.collectionName.find({'fieldname': {$operator: value } })
  -$eq : db.products.find({ 'price': { $eq: 699 } });

  -$ne : db.products.find({ 'price': { $ne: 699 } });

  -$gt : db.products.find({ 'price': { $gt: 699 } });

  - $gte : db.products.find({ 'price': { $gte: 699 } });

  -$lt : db.products.find({ 'price': { $lt: 699 } });

  -$lte : db.products.find({ 'price': { $lte: 699 } });

  -$in : db.category.find({price: { $in: [249, 129, 391]} });

  -$nin : db.category.find({price: { $nin: [249, 129, 391]} });


• Intro to Cursors: Cursors in MongoDB are used to efficiently retrieve large result sets from queries, providing control over the data retrieval process.
  - MongoDB retrieves query results in batches using cursors.
  - Cursors are a pointer to the result set on the server.
  - Cursors are used to iterate through query results.

 Automatic Batching: MongoDB retrieves query results in batches once.
                     Default batch size is usually 101 docs  (then it shows enter it(iterate) for more docs)
                     This improves memory efficiency and networking

• Cursor Methods: 
  - count() : db.products.find({ price: { $gt: 250 } }).count();
  - limit() : db.products.find({ price: { $gt: 250 } }).limit(5);
  - skip() : db.products.find({ price: { $gt: 250 } }).limit(5).skip(2);
  - sort() : db.products.find({ price: { $gt: 1250 } }'.limit(3).sort({price:1});                - (1) for ascending & (-1) for descending

     Performance Implications
       • skip() can be inefficient for large offsets.
       • Using sort() on large result sets may impact performance.

     Use with Caution
       • Be cautious when using limit() and skip() on large collections.
       • Consider using indexing to optimize query performance.



• Logical Operators:
  $and / $or / $nor: {$and: [{condition1}, {condition2}, ....] 
    ex.: db.products.find({ $and: [{'price': {$gt:100}}, {'name': 'Diamond Ring'}] })                              // both doc are true
         db.products.find({ $or: [{'price': {$gt:2000}}, {'name': 'Diamond Ring'}] })                              // atleast one doc is true
         db.products.find({ $nor: [{'price': {$gt:2000}}, {'name': 'Diamond Ring'}] }).count(4)                    // both are not true

  $not: {field:{ $not: {operator: value}}}
    ex.: db.products.find({ 'price':{$not: {$eq:100}} })         // jiske price 100 nahi hai give that doc
         db.products.find({ 'price':{$ne:100} }).count()


• Complex Expressions:
  The $expr operator allows using aggregation expressions within a query.
  Useful when you need to compare fields from the same document in a more complex manner.

Syntax: {$expr: {operator:[field,value]}}
 Ex. db.product.find({$expr: {gt:['$price',1340]}});
     db.sales.find({$expr: {$gt: [{$multiply: ['$quantity', '$price']}, '$targetPrice' ]} })               //if want to addition use add instead of Multiply


• Elements Operator:
  $exists: {field: {$exists: <boolean>}}         ex: db.products.find({ price: {$exists: true}})  | db.products.find({ price: {$exists: false}, price:{$gt:1250} })                        // use this to get no. of doc  .count()

  $type: {field: {$type: <bson-data-type>}}     $type: The $type operator filters documents based on the BSON data type of a field
     ex: db.products.find({ price: {$type: 'number'}})  | db.products.find({ price: {$type: 'string'}}) 

  $size: {field: {$size: <array-length>}}  : $size: The $size operator matches documents where the size of an array field matches a specified value.
     ex: db.comments.find({'comments':{$size:2}})        


## • Projection: 



















